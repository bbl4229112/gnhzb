/*
 * Generated by MyEclipse Struts
 * Template path: templates/java/JavaClass.vtl
 */
package edu.zju.cims201.GOF.util;


import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.Calendar;
import java.util.Comparator;
import java.util.Vector;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import javax.servlet.http.HttpServletResponse;
/** 
 * MyEclipse Struts
 * Creation date: 06-06-2008
 * 
 * XDoclet definition:
 * @struts.action validate="true"
 */
public class DownZipfile {
	/*
	 * Generated Methods
	 */

	/** 
	 * Method execute
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws IOException 
	 */
	
	class FileInfo {

		public String name = null, clientFileName = null, fileContentType = null;
		private byte[] fileContents = null;
		public File file = null;
		public StringBuffer sb = new StringBuffer(100);

		public void setFileContents(byte[] aByteArray) {
			fileContents = new byte[aByteArray.length];
			System.arraycopy(aByteArray, 0, fileContents, 0, aByteArray.length);}}
	public String getFileName(String dir, String fileName) throws IllegalArgumentException {
			String path = null;
			if (dir == null || fileName == null) throw new IllegalArgumentException(
					"dir or fileName is null");
			int index = fileName.lastIndexOf('/');
			String name = null;
			if (index >= 0) name = fileName.substring(index + 1);
			else name = fileName;
			index = name.lastIndexOf('\\');
			if (index >= 0) fileName = name.substring(index + 1);
			path = dir + File.separator + fileName;
			if (File.separatorChar == '/') return path.replace('\\', File.separatorChar);
			else return path.replace('/', File.separatorChar);
		}
	
	static Vector expandFileList(String[] files, boolean inclDirs) {
		Vector v = new Vector();
		if (files == null) return v;
		for (int i = 0; i < files.length; i++)
			v.add(new File(URLDecoder.decode(files[i])));
		for (int i = 0; i < v.size(); i++) {
			File f = (File) v.get(i);
			if (f.isDirectory()) {
				File[] fs = f.listFiles();
				for (int n = 0; n < fs.length; n++)
					v.add(fs[n]);
				if (!inclDirs) {
					v.remove(i);
					i--;
				}
			}
		}
		return v;
	}
	
	
	 
		static String getDir(String dir, String name) {
			if (!dir.endsWith(File.separator)) dir = dir + File.separator;
			File mv = new File(name);
			String new_dir = null;
			if (!mv.isAbsolute()) {
				new_dir = dir + name;
			}
			else new_dir = name;
			return new_dir;
		}

		/**
		 * This Method converts a byte size in a kbytes or Mbytes size, depending on the size
		 *     @param size The size in bytes
		 *     @return String with size and unit
		 */
		static String convertFileSize(long size){
			int divisor = 1;
			String unit = "bytes";
			if (size >= 1024 * 1024) {
				divisor = 1024 * 1024;
				unit = "MB";
			}
			else if (size >= 1024) {
				divisor = 1024;
				unit = "KB";
			}
			if (divisor == 1) return size / divisor + " " + unit;
			String aftercomma = "" + 100 * (size % divisor) / divisor;
			if (aftercomma.length() == 1) aftercomma = "0" + aftercomma;
			return size / divisor + "." + aftercomma + " " + unit;
		}

		/**
		 * Copies all data from in to out
		 * 	@param in the input stream
		 *	@param out the output stream
		 *	@param buffer copy buffer
		 */
		static void copyStreams(InputStream in, OutputStream out, byte[] buffer) throws IOException {
			copyStreamsWithoutClose(in, out, buffer);
			in.close();
			out.close();
		}

		/**
		 * Copies all data from in to out
		 * 	@param in the input stream
		 *	@param out the output stream
		 *	@param buffer copy buffer
		 */
		static void copyStreamsWithoutClose(InputStream in, OutputStream out, byte[] buffer)
				throws IOException {
			int b;
			while ((b = in.read(buffer)) != -1)
				out.write(buffer, 0, b);
		}

		/**
		 * Returns the Mime Type of the file, depending on the extension of the filename
		 */
		static String getMimeType(String fName) {
			fName = fName.toLowerCase();
			if (fName.endsWith(".jpg") || fName.endsWith(".jpeg") || fName.endsWith(".jpe")) return "image/jpeg";
			else if (fName.endsWith(".gif")) return "image/gif";
			else if (fName.endsWith(".pdf")) return "application/pdf";
			else if (fName.endsWith(".htm") || fName.endsWith(".html") || fName.endsWith(".shtml")) return "text/html";
			else if (fName.endsWith(".avi")) return "video/x-msvideo";
			else if (fName.endsWith(".mov") || fName.endsWith(".qt")) return "video/quicktime";
			else if (fName.endsWith(".mpg") || fName.endsWith(".mpeg") || fName.endsWith(".mpe")) return "video/mpeg";
			else if (fName.endsWith(".zip")) return "application/zip";
			else if (fName.endsWith(".tiff") || fName.endsWith(".tif")) return "image/tiff";
			else if (fName.endsWith(".rtf")) return "application/rtf";
			else if (fName.endsWith(".mid") || fName.endsWith(".midi")) return "audio/x-midi";
			else if (fName.endsWith(".xl") || fName.endsWith(".xls") || fName.endsWith(".xlv")
					|| fName.endsWith(".xla") || fName.endsWith(".xlb") || fName.endsWith(".xlt")
					|| fName.endsWith(".xlm") || fName.endsWith(".xlk")) return "application/excel";
			else if (fName.endsWith(".doc") || fName.endsWith(".dot")) return "application/msword";
			else if (fName.endsWith(".png")) return "image/png";
			else if (fName.endsWith(".xml")) return "text/xml";
			else if (fName.endsWith(".svg")) return "image/svg+xml";
			else if (fName.endsWith(".mp3")) return "audio/mp3";
			else if (fName.endsWith(".ogg")) return "audio/ogg";
			else return "text/plain";
		}

		/**
		 * Converts some important chars (int) to the corresponding html string
		 */
		static String conv2Html(int i) {
			if (i == '&') return "&amp;";
			else if (i == '<') return "&lt;";
			else if (i == '>') return "&gt;";
			else if (i == '"') return "&quot;";
			else return "" + (char) i;
		}

		/**
		 * Converts a normal string to a html conform string
		 */
		static String conv2Html(String st) {
			StringBuffer buf = new StringBuffer();
			for (int i = 0; i < st.length(); i++) {
				buf.append(conv2Html(st.charAt(i)));
			}
			return buf.toString();
		}

		/**
		 * Starts a native process on the server
		 * 	@param command the command to start the process
		 *	@param dir the dir in which the process starts
		 */
		private static final String[] COMMAND_INTERPRETER = {"cmd", "/C"}; // Dos,Windows
		private static final long MAX_PROCESS_RUNNING_TIME = 30 * 1000; //30 seconds
		static String startProcess(String command, String dir) throws IOException {
			StringBuffer ret = new StringBuffer();
			String[] comm = new String[3];
			comm[0] = COMMAND_INTERPRETER[0];
			comm[1] = COMMAND_INTERPRETER[1];
			comm[2] = command;
			long start = System.currentTimeMillis();
			try {
				//Start process
				Process ls_proc = Runtime.getRuntime().exec(comm, null, new File(dir));
				//Get input and error streams
				BufferedInputStream ls_in = new BufferedInputStream(ls_proc.getInputStream());
				BufferedInputStream ls_err = new BufferedInputStream(ls_proc.getErrorStream());
				boolean end = false;
				while (!end) {
					int c = 0;
					while ((ls_err.available() > 0) && (++c <= 1000)) {
						ret.append(conv2Html(ls_err.read()));
					}
					c = 0;
					while ((ls_in.available() > 0) && (++c <= 1000)) {
						ret.append(conv2Html(ls_in.read()));
					}
					try {
						ls_proc.exitValue();
						//if the process has not finished, an exception is thrown
						//else
						while (ls_err.available() > 0)
							ret.append(conv2Html(ls_err.read()));
						while (ls_in.available() > 0)
							ret.append(conv2Html(ls_in.read()));
						end = true;
					}
					catch (IllegalThreadStateException ex) {
						//Process is running
					}
					//The process is not allowed to run longer than given time.
					if (System.currentTimeMillis() - start > MAX_PROCESS_RUNNING_TIME) {
						ls_proc.destroy();
						end = true;
						ret.append("!!!! Process has timed out, destroyed !!!!!");
					}
					try {
						Thread.sleep(50);
					}
					catch (InterruptedException ie) {}
				}
			}
			catch (IOException e) {
				ret.append("Error: " + e);
			}
			return ret.toString();
		}

		/**
		 * Converts a dir string to a linked dir string
		 * 	@param dir the directory string (e.g. /usr/local/httpd)
		 *	@param browserLink web-path to Browser.jsp
		 */
		static String dir2linkdir(String dir, String browserLink, int sortMode) {
			File f = new File(dir);
			StringBuffer buf = new StringBuffer();
			while (f.getParentFile() != null) {
				if (f.canRead()) {
					String encPath = URLEncoder.encode(f.getAbsolutePath());
					buf.insert(0, "<a href=\"" + browserLink + "?sort=" + sortMode + "&amp;dir="
							+ encPath + "\">" + conv2Html(f.getName()) + File.separator + "</a>");
				}
				else buf.insert(0, conv2Html(f.getName()) + File.separator);
				f = f.getParentFile();
			}
			if (f.canRead()) {
				String encPath = URLEncoder.encode(f.getAbsolutePath());
				buf.insert(0, "<a href=\"" + browserLink + "?sort=" + sortMode + "&amp;dir=" + encPath
						+ "\">" + conv2Html(f.getAbsolutePath()) + "</a>");
			}
			else buf.insert(0, f.getAbsolutePath());
			return buf.toString();
		}

		/**
		 *	Returns true if the given filename tends towards a packed file
		 */
		static boolean isPacked(String name, boolean gz) {
			return (name.toLowerCase().endsWith(".zip") || name.toLowerCase().endsWith(".jar")
					|| (gz && name.toLowerCase().endsWith(".gz")) || name.toLowerCase()
					.endsWith(".war"));
		}

		/**
		 *	If RESTRICT_BROWSING = true this method checks, whether the path is allowed or not
		 */
//		static boolean isAllowed(File path, boolean write) throws IOException{
//			if (READ_ONLY && write) return false;
//			if (RESTRICT_BROWSING) {
//	            StringTokenizer stk = new StringTokenizer(RESTRICT_PATH, ";");
//	            while (stk.hasMoreTokens()){
//				    if (path!=null && path.getCanonicalPath().startsWith(stk.nextToken()))
//	                    return RESTRICT_WHITELIST;
//	            }
//	            return !RESTRICT_WHITELIST;
//			}
//			else return true;
//		}
	
	
	

	   


	
			


		
	//End of class HttpMultiPartParser

		/**
		 * This class is a comparator to sort the filenames and dirs
		 */
		class FileComp implements Comparator {

			int mode;
			int sign;

			FileComp() {
				this.mode = 1;
				this.sign = 1;
			}

			/**
			 * @param mode sort by 1=Filename, 2=Size, 3=Date, 4=Type
			 * The default sorting method is by Name
			 * Negative mode means descending sort
			 */
			FileComp(int mode) {
				if (mode < 0) {
					this.mode = -mode;
					sign = -1;
				}
				else {
					this.mode = mode;
					this.sign = 1;
				}
			}

			public int compare(Object o1, Object o2) {
				File f1 = (File) o1;
				File f2 = (File) o2;
				if (f1.isDirectory()) {
					if (f2.isDirectory()) {
						switch (mode) {
						//Filename or Type
						case 1:
						case 4:
							return sign
									* f1.getAbsolutePath().toUpperCase().compareTo(
											f2.getAbsolutePath().toUpperCase());
						//Filesize
						case 2:
							return sign * (new Long(f1.length()).compareTo(new Long(f2.length())));
						//Date
						case 3:
							return sign
									* (new Long(f1.lastModified())
											.compareTo(new Long(f2.lastModified())));
						default:
							return 1;
						}
					}
					else return -1;
				}
				else if (f2.isDirectory()) return 1;
				else {
					switch (mode) {
					case 1:
						return sign
								* f1.getAbsolutePath().toUpperCase().compareTo(
										f2.getAbsolutePath().toUpperCase());
					case 2:
						return sign * (new Long(f1.length()).compareTo(new Long(f2.length())));
					case 3:
						return sign
								* (new Long(f1.lastModified()).compareTo(new Long(f2.lastModified())));
					case 4: { // Sort by extension
						int tempIndexf1 = f1.getAbsolutePath().lastIndexOf('.');
						int tempIndexf2 = f2.getAbsolutePath().lastIndexOf('.');
						if ((tempIndexf1 == -1) && (tempIndexf2 == -1)) { // Neither have an extension
							return sign
									* f1.getAbsolutePath().toUpperCase().compareTo(
											f2.getAbsolutePath().toUpperCase());
						}
						// f1 has no extension
						else if (tempIndexf1 == -1) return -sign;
						// f2 has no extension
						else if (tempIndexf2 == -1) return sign;
						// Both have an extension
						else {
							String tempEndf1 = f1.getAbsolutePath().toUpperCase()
									.substring(tempIndexf1);
							String tempEndf2 = f2.getAbsolutePath().toUpperCase()
									.substring(tempIndexf2);
							return sign * tempEndf1.compareTo(tempEndf2);
						}
					}
					default:
						return 1;
					}
				}
			}
		}

//		/**
//		 * Wrapperclass to wrap an OutputStream around a Writer
//		 */
//		class Writer2Stream extends OutputStream {
//
//			Writer out;
//
////			Writer2Stream(Writer w) {
////				super();
////				out = w;
////			}
//
//			public void write(int i) throws IOException {
//				System.out.println(i);
//				out.write(i);
//			}
//
//			public void write(byte[] b) throws IOException {
//				for (int i = 0; i < b.length; i++) {
//					int n = b[i];
//					//Convert byte to ubyte
//					n = ((n >>> 4) & 0xF) * 16 + (n & 0xF);
//					out.write(n);
//				}
//			}
//
//			public void write(byte[] b, int off, int len) throws IOException {
//				for (int i = off; i < off + len; i++) {
//					int n = b[i];
//					n = ((n >>> 4) & 0xF) * 16 + (n & 0xF);
//					out.write(n);
//				}
//			}
//		} //End of class Writer2Stream

public void downZipfile(String[] filename,HttpServletResponse response,String dir  ) throws IOException{

// 获得需要下载的文档名
	try{
				Vector v = expandFileList(filename, false);
				//Check if all files in vector are allowed
//				for (int i = 0; i < filename.length; i++) {
//				//System.out.println("filename="+filename[i]);}
				Calendar cal = new java.util.GregorianCalendar();
				int hour = cal.get(java.util.Calendar.HOUR_OF_DAY);
				int min = cal.get(java.util.Calendar.MINUTE);
				int sec = cal.get(java.util.Calendar.SECOND);
				
				int year = cal.get(java.util.Calendar.YEAR);
				int month = cal.get(java.util.Calendar.MONTH) + 1;
				int day = cal.get(java.util.Calendar.DATE);
				String 	mtime =""+ year+"" + month+"" + day+"" + hour+"" + min+"" +sec;
				
					File dir_file = new File(dir);
					System.out.println("dir_file="+dir_file);
					int dir_l = dir_file.getAbsolutePath().length();
				//	System.out.println("dir_l="+dir_l);
					response.reset();
					response.setContentType("application/zip");
					response.setHeader("Content-Disposition", "attachment;filename=\"download"+mtime+".zip\"");
					OutputStream out = response.getOutputStream();
					ZipOutputStream zipout = new ZipOutputStream(out);
					for (int i = 0; i < v.size(); i++) {
						System.out.println( v.get(i));
						File f = (File) v.get(i);
						System.out.println("dir_l="+dir_l);
						if(f.isFile()){System.out.println("is file");}
						if (f.canRead()) {
							System.out.println("file="+f.getAbsolutePath());
							
							zipout.putNextEntry(new ZipEntry(f.getAbsolutePath().substring(dir_l + 1)));
							FileInputStream fi=	new FileInputStream(f);
							BufferedInputStream fr = new BufferedInputStream(fi);
							byte buffer[] = new byte[0xffff];
							copyStreamsWithoutClose(fr, zipout, buffer);
							/*					int b;
							 while ((b=fr.read())!=-1) zipout.write(b);*/
							fr.close();
							fi.close();
							zipout.closeEntry();
						}
					}
					zipout.finish();
//					out.flush();
					out.close();

	
	}
catch(Exception e){
e.printStackTrace();	
}
}
public void downZipfile2(HttpServletResponse response,String[] savepath,String dir) throws IOException{

//	 获得需要下载的文档名
		try{       
					Vector v = expandFileList(savepath, false);
					
					//Check if all files in vector are allowed
//					for (int i = 0; i < filename.length; i++) {
//					//System.out.println("filename="+filename[i]);}
					Calendar cal = new java.util.GregorianCalendar();
					int hour = cal.get(java.util.Calendar.HOUR_OF_DAY);
					int min = cal.get(java.util.Calendar.MINUTE);
					int sec = cal.get(java.util.Calendar.SECOND);
					
					int year = cal.get(java.util.Calendar.YEAR);
					int month = cal.get(java.util.Calendar.MONTH) + 1;
					int day = cal.get(java.util.Calendar.DATE);
				String 	mtime =""+ year+"" + month+"" + day+"" + hour+"" + min+"" +sec;
					
						File dir_file = new File(dir);
						System.out.println("dir_file="+dir_file);
						int dir_l = dir_file.getAbsolutePath().length();
					//	System.out.println("dir_l="+dir_l);
						response.setContentType("application/zip");
						response.setHeader("Content-Disposition", "attachment;filename=\"download"+mtime+".zip\"");
						OutputStream out = response.getOutputStream();
						ZipOutputStream zipout = new ZipOutputStream(out);
						for (int i = 0; i < v.size(); i++) {
							//System.out.println( "file="+v.get(i));
							System.out.println("onlyfile="+ v.get(i));
							File f = (File) v.get(i);
						//	System.out.println("dir_l="+dir_l);
							if(f.isFile()){//System.out.println("is file");
							if (f.canRead()) {
							//	System.out.println("file="+f.getAbsolutePath());
								
								zipout.putNextEntry(new ZipEntry(f.getAbsolutePath().substring(dir_l + 1)));
								FileInputStream fi=	new FileInputStream(f);
								BufferedInputStream fr = new BufferedInputStream(fi);
								byte buffer[] = new byte[0xffff];
								copyStreamsWithoutClose(fr, zipout, buffer);
								/*					int b;
								 while ((b=fr.read())!=-1) zipout.write(b);*/
								fr.close();
								fi.close();
								zipout.closeEntry();
							}}

						
						
						
						
						
						
						}
						zipout.finish();
						out.close();

		
		}
	catch(Exception e){
	e.printStackTrace();	
	}
	}

}